The function `l2cap_sock_release(sk)` frees `sk`, however, sk's children are still alive and point to the already free'd sk's address, because `l2cap_sock_release(sk)` does not clean sk's children. This can cause a use-after-free.